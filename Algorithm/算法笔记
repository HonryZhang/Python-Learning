一、计算方法
1.一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。
一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。
2.一般情况下，算法的基本操作重复执行的次数是模块n的某一个函数f（n），因此，算法的时间复杂度记做：T（n）=O（f（n））。随着模块n的增大，算法执行的时间的增长率和f（n）的增长率成正比，所以f（n）越小，算法的时间复杂度越低，算法的效率越高。
在计算时间复杂度的时候，先找出算法的基本操作，然后根据相应的各语句确定它的执行次数，再找出T（n）的同数量级（它的同数量级有以下：1，Log2n ，n ，nLog2n ，n的平方，n的三次方，2的n次方，n！），找出后，f（n）=该数量级，若T(n)/f(n)求极限可得到一常数c，则时间复杂度T（n）=O（f（n））。
3.常见的时间复杂度
按数量级递增排列，常见的时间复杂度有：
常数阶O(1),  对数阶O(log2n),  线性阶O(n),  线性对数阶O(nlog2n),  平方阶O(n^2)， 立方阶O(n^3),...， k次方阶O(n^k), 指数阶O(2^n) 。
其中，
1.O(n)，O(n^2)， 立方阶O(n^3),...， k次方阶O(n^k) 为多项式阶时间复杂度，分别称为一阶时间复杂度，二阶时间复杂度。。。。
2.O(2^n)，指数阶时间复杂度，该种不实用
3.对数阶O(log2n),   线性对数阶O(nlog2n)，除了常数阶以外，该种效率最高


冒泡排序 O(n*n) 将待排序的元素看做是竖着排列的气泡，较小的元素比较轻，从而要上浮。

插入排序 O(n*n) 逐一取出元素，在已经排序的元素序列中从后向前扫描，放到适当的位置。

选择排序 O(n*n) 首先在未排序的序列中找出最小元素，存放到排序序列的起始位置，然后，从剩余未排序元素中继续寻找最小元素，然后放到排序序列末尾，以此类推。

快速排序 O(n *log2(n)) 先选择中间值，然后把比他小的放在左边，大的放在右边（具体的实现是从两边找，找到一对后交换），然后对两边分别使用这个过程（递归实现）

堆排序 O(n *log2(n)) 利用堆（heaps)这种数据结构来构造的一种排序算法。堆是一个近似完全二叉树结构，并同时满足堆属性：即子节点的键值或索引总是小于或者大于它的父节点。

希尔排序：O(n1+￡) 0<￡<1 选择一个步长(Step) ,然后按间隔为步长的单元进行排序.递归,步长逐渐变小,直至为1.

箱排序 O(n) 设置若干个箱子，把关键字等于 k 的记录全都装入到第k 个箱子里 ( 分配 ) ，然后按序号依次将各非空的箱子首尾连接起来 ( 收集 )